<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="shortcut icon" href="icons/favicon.ico" />
  <link rel="icon" type="image/png" href="icons/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="icons/favicon.svg" />
  <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png" />
  <meta name="apple-mobile-web-app-title" content="post.to" />
  <link rel="manifest" href="icons/site.webmanifest" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>post.to</title>
  <style>
    @font-face {
      font-family: "JetBrains Mono";
      src: url("webfonts/JetBrainsMono-Regular.woff2") format("woff2");
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    * {
      box-sizing: border-box;      
      margin: 0;
      padding: 0;
      border: none;
      color-scheme: dark;
      font-family: "JetBrains Mono", "SF Mono", Consolas, monospace;
      font-size: 16.5px;    	
      letter-spacing: 0.5px;
      line-height: 27px;
    }
    
    /* Global styles */
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
      background-color: rgb(27, 27, 27);      
    }

    /* Big textarea occupies the whole page */
    #txtArea {
      padding: 29px;
      padding-right: 21px;
      padding-top: 71px;
      /*padding-left: 65px;*/
      width: 100%;
      height: 100%;
      color: rgb(225, 225, 225);
      background-color: rgb(27, 27, 27);
      resize: none;
	  -webkit-appearance: none;
	  caret-color: white;

      /*overflow-y: scroll;
      white-space: pre;*/
    }

    #txtArea:focus {
      outline: none;
      border: none;
    }

    /*
	#rowNumbers {
	  padding-top: 27px;
	  width: 61px;
	  position: absolute;
	  height: 100%;
	  color: rgba(255, 255, 255, 0.15);
	  background-color: rgb(27, 27, 27);
	  left: 0;
	  top: 0;
	  cursor: pointer;
	  text-align: center;
	  pointer-events: none;
	}

	#rowNumbers div {
	  line-height: 27px;
	  color: rgba(255, 255, 255, 0.15);
	}
	*/

	/*
	#rowNumbers div:last-child {
	  color: rgba(255, 255, 255, 0.05);
	}
	*/

	/* Position the container absolutely in the top right corner */
	#topButtons {
	  position: absolute;
	  top: 0px;
	  /*top: 0px;right: 0px;*/
	  left: 50%; 
	  transform: translateX(-50%);
	  padding: 15px; /* Padding adds space around the buttons */
	  padding-bottom: 13px;
	  padding-top: 13px;
	  background-color: rgba(27, 27, 25, 0.85);
	  display: flex;
	  flex-direction: row; 
	  gap: 20px; /* Space between buttons */
	  z-index: 1000; 
	  pointer-events: none;
	  justify-content: center; /* Centers buttons within the container */
	  border-radius: 0px 0px 30px 30px;
	  /* Removed fixed width: 140px */
	}

	#topButtons button {
	  pointer-events: auto;
	  width: 40px;
	  height: 40px;
	  border-radius: 50%;
	  border: none;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  cursor: pointer;
	  outline: none;
	}


	/* "Push" button: green circle with an upward arrow */
	/* "Add" button: light gray background with dark text */
	/* Add a transition to the buttons for smooth effects */
	#topButtons button {
	  transition: transform 0.2s ease, box-shadow 0.2s ease;
	}

	/* On hover, scale up the button and add a subtle shadow */
	#topButtons button:hover {
	  transform: scale(1.1);
	  cursor: pointer;
	  /* box-shadow: 0px 0px 3px rgba(0, 0, 0, 1); */
	}

	button:not(:hover) {
 	  transform: scale(1); /* Ensures it returns to original size */
	}
/* 
	#topButtons button.active {
		box-shadow: none;
	}
*/
	/* Common button styling already defined for #pushButton, etc. */

	/* Additional styling for the disabled state of the push button */
	#topButtons button.disabled {
	  opacity: 0.6;
	  background-color: #717171;
	}


	/* You might also add a hover effect for normal state if desired
	#topButtons button:hover:not(.disabled) {
	  transform: scale(1.1);
	  background-color: #717171;	  
	  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
	} */

	/* Normal push button: green */

	#addButton, #linkButton, #copyButton {
	  background-color: #858585;
	  color: white;
	}

	#addButton.active, #linkButton.active, #copyButton.active  {
	  background-color: #717171;
	}

	#pushButton {
	  background-color: #4CAF50;
	  color: white;
	}

	/* When active (pressed), make push button darker */
	#pushButton.active {
	  background-color: #388E3C;
	}

	/* Normal pull button: blue */
	#pullButton {
	  background-color: #2196F3;
	  color: white;
	}

	/* When active (pressed), make pull button darker */
	#pullButton.active {
	  background-color: #1976D2;
	}

	#leftIconButton {
		background-color: transparent;
	  	transform: scale(1.1);
	}


  </style>
</head>

<body>
	<textarea id="txtArea" spellcheck="false" autocapitalize="none" 
    		  autocomplete="off" autocorrect="off" spellcheck="false" placeholder=""></textarea>
	<!--<div id="rowNumbers"></div>--> <!--autofocus-->

	<div id="topButtons">

		<!-- source: https://logosandtypes.com/wp-content/uploads/2024/12/pieces-developers.svg -->
	  <button id="leftIconButton" aria-label="post.to" title="post.to">
	    <svg xmlns="http://www.w3.org/2000/svg" width="45" height="45" viewBox="0 0 150 150"><path d="M77.54,10.27c-25.27-.05-46.73,19.18-49.36,44.14-.17,1.39-.27,2.74-.27,4.13v53.03c2.2,42.75,63.41,39.36,61.09-3.75,56.46-14.94,47.37-96.09-11.46-97.55Zm.22,87.18c-8.94-1.44-15.73-9.18-15.73-18.23v-10.84c.13-4.29,3.7-7.68,7.99-7.61,4.29,.08,7.74,3.56,7.74,7.85v28.82Zm11.27-1.52v-27.6c-1.37-24.96-36.86-24.9-38.22,0v11.38c.24,15.16,11.84,27.71,26.95,29.09v2.85c-.16,10.51-8.75,18.96-19.29,18.96-10.64,.05-19.33-8.63-19.31-19.29,.14-.91-.52-42.39,.22-55.88,1.62-19.32,18.48-34.22,38.14-34.2,43.98,.84,52.9,61.02,11.52,74.68Z" style="fill:#e1e1e1" ></svg>
	  </button>


	  <button id="pushButton" aria-label="Save to cloud" title="Save to cloud">
	    <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
	      <path fill-rule="evenodd" clip-rule="evenodd" d="M15.1918 8.90615C15.6381 8.45983 16.3618 8.45983 16.8081 8.90615L21.9509 14.049C22.3972 14.4953 22.3972 15.2189 21.9509 15.6652C21.5046 16.1116 20.781 16.1116 20.3347 15.6652L17.1428 12.4734V22.2857C17.1428 22.9169 16.6311 23.4286 15.9999 23.4286C15.3688 23.4286 14.8571 22.9169 14.8571 22.2857V12.4734L11.6652 15.6652C11.2189 16.1116 10.4953 16.1116 10.049 15.6652C9.60265 15.2189 9.60265 14.4953 10.049 14.049L15.1918 8.90615Z" fill="currentColor"></path>
	    </svg>
	  </button>
	  <button id="pullButton" aria-label="Load from cloud" title="Load from cloud">
	    <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: rotate(180deg);">
	      <path fill-rule="evenodd" clip-rule="evenodd" d="M15.1918 8.90615C15.6381 8.45983 16.3618 8.45983 16.8081 8.90615L21.9509 14.049C22.3972 14.4953 22.3972 15.2189 21.9509 15.6652C21.5046 16.1116 20.781 16.1116 20.3347 15.6652L17.1428 12.4734V22.2857C17.1428 22.9169 16.6311 23.4286 15.9999 23.4286C15.3688 23.4286 14.8571 22.9169 14.8571 22.2857V12.4734L11.6652 15.6652C11.2189 16.1116 10.4953 16.1116 10.049 15.6652C9.60265 15.2189 9.60265 14.4953 10.049 14.049L15.1918 8.90615Z" fill="currentColor"></path>
	    </svg>
	  </button>

	  <button id="addButton" aria-label="New" title="New">
		  <svg width="14" height="14" viewBox="0 0 45.402 45.402" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
		      <path d="M41.267,18.557H26.832V4.134C26.832,1.851,24.99,0,22.707,0c-2.283,0-4.124,1.851-4.124,4.135v14.432H4.141
		        c-2.283,0-4.139,1.851-4.138,4.135c-0.001,1.141,0.46,2.187,1.207,2.934c0.748,0.749,1.78,1.222,2.92,1.222h14.453V41.27
		        c0,1.142,0.453,2.176,1.201,2.922c0.748,0.748,1.777,1.211,2.919,1.211c2.282,0,4.129-1.851,4.129-4.133V26.857h14.435
		        c2.283,0,4.134-1.867,4.133-4.15C45.399,20.425,43.548,18.557,41.267,18.557z"/>
		  </svg>	  
	  </button>
	  
		<button id="copyButton" aria-label="Copy all" title="Copy all">
		  <svg xmlns="http://www.w3.org/2000/svg" width="19" height="19" viewBox="0 0 267.17969 270.98047" fill="currentColor">
		    <path d="M 112.08984,0 C 91.590841,0 75,17.076639 75,37.791015 v 9.09961 c 8.4e-4,4.159501 3.430342,7.589004 7.589844,7.589843 h 14.699219 c 4.159507,-8.39e-4 7.589007,-3.430342 7.589847,-7.589843 v -9.09961 c 0,-4.222983 3.37425,-7.511719 7.21093,-7.511719 h 118 c 4.01999,0 7.21094,3.197408 7.21094,7.511719 V 158.68945 c 0,4.48868 -3.098,7.51172 -7.21094,7.51172 h -8.80078 c -4.15951,8.3e-4 -7.58901,3.43033 -7.58985,7.58984 v 15.09961 c 8.4e-4,4.15951 3.43034,7.58901 7.58985,7.58984 h 8.80078 c 20.499,0 37.08984,-17.07664 37.08984,-37.79101 V 37.791015 C 267.17968,17.076639 250.58884,0 230.08984,0 Z M 37.089844,74.40039 C 16.563064,74.40039 0,91.578505 0,112.29101 v 120.89844 c 0,20.71437 16.590841,37.79101 37.089844,37.79101 H 155.08984 c 20.499,0 37.08984,-17.07664 37.08984,-37.79101 v -121 c 0,-20.714412 -16.59138,-37.78906 -37.08984,-37.78906 z m 0,30.37891 H 155.08984 c 4.01999,0 7.21094,3.19741 7.21094,7.51171 v 120.89844 c 0,4.22298 -3.37425,7.51172 -7.21094,7.51172 H 37.089844 c -4.019989,0 -7.210938,-3.19741 -7.210938,-7.51172 V 112.29101 c 0,-4.22298 3.374253,-7.51171 7.210938,-7.51171 z" />
		  </svg>
		</button>

		<button id="linkButton" aria-label="Copy link" title="Copy link">
		  <svg width="17" height="17" viewBox="0 0 19.534 19.522" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
		    <path d="M14.345 0c-1.601-.023-3.097.798-4.133 1.984L6.724 5.526c-1.512 1.872-1.438 4.777.161 6.574.434.736 1.608.863 2.079.1.536-.735-.1-1.489-.572-2.035-.756-1.197-.388-2.849.699-3.715l3.575-3.535c1.34-1.078 3.565-.537 4.241 1.049.6 1.185.16 2.666-.843 3.481-.486.548-1.326 1.031-1.142 1.885.149.978 1.542 1.282 2.113.488 1.004-.974 2.074-2.004 2.35-3.441.671-2.566-.979-5.444-3.537-6.153-.486-.148-.994-.225-1.503-.225zm-2.828 6.826c-1.013-.054-1.59 1.338-.838 2.018 1.18 1.108 1.056 3.174-.195 4.18L6.865 16.61c-1.339 1.118-3.598.565-4.279-1.038-.581-1.181-.156-2.651.845-3.462.479-.529 1.281-1.015 1.088-1.849-.154-.958-1.514-1.262-2.087-.497-.94.907-1.922 1.871-2.233 3.192-.762 2.514.749 5.435 3.247 6.257 2.009.767 4.381.053 5.76-1.561l3.568-3.625c1.511-1.872 1.439-4.777-.161-6.574-.267-.343-.639-.638-1.097-.625z"/>
		  </svg>
		</button>	

	</div>

  <script>
	
	// DOM elements	
	const txtArea = document.getElementById("txtArea");
	//const rowNumbers = document.getElementById("rowNumbers");
	const addButton = document.getElementById("addButton");
	const copyButton = document.getElementById("copyButton");
	const linkButton = document.getElementById("linkButton");
	const pushButton = document.getElementById("pushButton");
	const pullButton = document.getElementById("pullButton");

	// Global variables
	var anchor = "";
	var wasEdited = false;
	// Global cache for computed hashes (seed → { anchorHash, h2 }).
	var computedHashes = {};

  /****************************
   * Helper functions *
   ****************************/

	/*
	function hash(x) {
	  // For now, return x as is.
	  return x;
	}

	function compress(x) {
	  // Identity for now.
	  return x;
	}

	function decompress(x) {
	  // Identity for now.
	  return x;
	}
	*/

		// Asynchronous function to compress text into a gzip binary.
		async function compressTextToGzip(text) {
		  const encoder = new TextEncoder();
		  const inputData = encoder.encode(text);

		  const cs = new CompressionStream("gzip");
		  const writer = cs.writable.getWriter();
		  writer.write(inputData);
		  writer.close();

		  const compressedResponse = new Response(cs.readable);
		  const compressedData = await compressedResponse.arrayBuffer();
		  return compressedData;
		}

		// Asynchronous function to decompress a gzip binary back to text.
		async function uncompressGzipToText(gzipData) {
		  const uint8Data = new Uint8Array(gzipData);
		  const compressedStream = new Response(uint8Data).body;
		  const ds = new DecompressionStream("gzip");
		  const decompressedStream = compressedStream.pipeThrough(ds);
		  const decompressedResponse = new Response(decompressedStream);
		  const text = await decompressedResponse.text();
		  return text;
		}


	// Helper: Convert a Uint8Array (or ArrayBuffer) to a base64url encoded string.
	function bufferToBase64Url(buffer) {
	  let binary = "";
	  const bytes = new Uint8Array(buffer);
	  for (let i = 0; i < bytes.byteLength; i++) {
	    binary += String.fromCharCode(bytes[i]);
	  }
	  // Standard base64
	  let base64 = btoa(binary);
	  // Convert to base64url by replacing characters and removing padding.
	  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, ''); // removes the last "=="
	}

	async function computeSHA1Base64(text) {
	  // 1. Create a TextEncoder and encode the input text.
	  const encoder = new TextEncoder();
	  const data = encoder.encode(text);
	  
	  // 2. Compute the SHA‑1 digest of the encoded data.
	  const hashBuffer = await crypto.subtle.digest("SHA-1", data);
	  
	  // 3. Convert the resulting ArrayBuffer to a base64‑encoded string.
	  return bufferToBase64Url(hashBuffer);
	}	

	// Helper: Compute anchorHash (h1 cropped & Base64-encoded with no trailing "=")
	// and h2 from a seed.
	async function computeHashes(seed) {
	  const encoder = new TextEncoder();
	  const data1 = encoder.encode(seed + "salt1");
	  const data2 = encoder.encode(seed + "salt2");

	  // Compute both digests concurrently.
	  const [hashBuffer1, hashBuffer2] = await Promise.all([
	    crypto.subtle.digest("SHA-256", data1),
	    crypto.subtle.digest("SHA-256", data2)
	  ]);

	  // h1: crop to the first 30 bytes (240 bits).
	  const h1 = new Uint8Array(hashBuffer1).slice(0, 30);
	  // Convert to Base64.
	  let base64 = bufferToBase64Url(h1);
	  
	  return {
	    anchorHash: base64, // This is our record ID.
	    h2: new Uint8Array(hashBuffer2) // AES key raw material.
	  };
	}

	// Helper: Import a raw key (Uint8Array) as an AES-GCM key.
	async function importAesKey(rawKey) {
	  return await crypto.subtle.importKey(
	    "raw",
	    rawKey,
	    { name: "AES-GCM" },
	    false, // non-extractable
	    ["encrypt", "decrypt"]
	  );
	}

	// Helper: Encrypt an ArrayBuffer with AES-GCM.
	// Returns an ArrayBuffer with IV (12 bytes) prepended to the ciphertext.
	async function encryptData(dataBuffer, aesKey) {
	  const iv = crypto.getRandomValues(new Uint8Array(12));
	  const cipherBuffer = await crypto.subtle.encrypt(
	    { name: "AES-GCM", iv },
	    aesKey,
	    dataBuffer
	  );
	  const ivAndCipher = new Uint8Array(iv.byteLength + cipherBuffer.byteLength);
	  ivAndCipher.set(iv, 0);
	  ivAndCipher.set(new Uint8Array(cipherBuffer), iv.byteLength);
	  return ivAndCipher.buffer;
	}

	// Helper: Decrypt an ArrayBuffer with AES-GCM.
	// Expects the first 12 bytes to be the IV.
	async function decryptData(encryptedBuffer, aesKey) {
	  const encryptedArray = new Uint8Array(encryptedBuffer);
	  const iv = encryptedArray.slice(0, 12);
	  const ciphertext = encryptedArray.slice(12);
	  const plainBuffer = await crypto.subtle.decrypt(
	    { name: "AES-GCM", iv },
	    aesKey,
	    ciphertext
	  );
	  return plainBuffer;
	}

	function generateRandomAnchor(numBytes) {
	   if ( !numBytes )
	   		numBytes = 30;
	   let randomBytes = new Uint8Array(numBytes);  // 18*8=144 bits or 21*8 = 168 bits or 30*8 = 240?
	   crypto.getRandomValues(randomBytes);
	   return bufferToBase64Url(randomBytes);
	}

  /****************************
   * Helper functions *
   ****************************/

	function addActiveListeners(button) {
	  button.addEventListener("mousedown", () => {
	    button.classList.add("active");
	  });
	  button.addEventListener("touchstart", () => {
	    button.classList.add("active");
	  });
	  // Remove the active class when the pointer is released or leaves.
	  button.addEventListener("mouseup", () => {
	    button.classList.remove("active");
	  });
	  button.addEventListener("mouseleave", () => {
	    button.classList.remove("active");
	  });
	  button.addEventListener("touchend", () => {
	    button.classList.remove("active");
	  });
	  button.addEventListener("touchcancel", () => {
	    button.classList.remove("active");
	  });	  
	}

	// Apply the active listeners.
	addActiveListeners(addButton);
	addActiveListeners(copyButton);
	addActiveListeners(linkButton);
	addActiveListeners(pushButton);
	addActiveListeners(pullButton);

	copyButton.addEventListener("click", function() {
    // Use the Clipboard API to copy the current URL
		//this.classList.remove("active");

	    navigator.clipboard.writeText(txtArea.value)
	      .then(() => {
	        // alert("Textarea copied to clipboard!");
	      })
	      .catch(err => {
	        console.error("Failed to copy textarea content: ", err);
	      });
  	});

	linkButton.addEventListener("click", function() {
    // Use the Clipboard API to copy the current URL
		//this.classList.remove("active");

	    navigator.clipboard.writeText(window.location.href)
	      .then(() => {
	        // alert("URL copied to clipboard!");
	      })
	      .catch(err => {
	        console.error("Failed to copy URL: ", err);
	      });
  	});

	addButton.addEventListener("click", newDoc);

	// -------------------- PUSH --------------------

	pushButton.addEventListener("click", async function() {
	  if (pushButton.disabled) return;
	  pushButton.disabled = true;

	  try {
	    // anchor is your seed (a base62 string).
	    const seed = anchor;
	    
	    // Use cached computed hashes if available.
	    if (!computedHashes[seed]) {
	      computedHashes[seed] = await computeHashes(seed);
	    }
	    const { anchorHash, h2 } = computedHashes[seed];

	    // Get text from the text area.
	    const text = txtArea.value;
	    // Append a salt to the text before hashing.
	    const saltedText = text + "salt";

	    // Compute the SHA-1 hash (base64 encoded) of the salted text.
	    const textHashBase64 = await computeSHA1Base64(saltedText);
	    //console.log("SHA-1 (base64) of salted text:", textHashBase64);

	    // Compress the original text.
	    const compressedData = await compressTextToGzip(text);

	    // Derive an AES key from h2.
	    const aesKey = await importAesKey(h2);

	    // Encrypt the compressed data.
	    const encryptedData = await encryptData(compressedData, aesKey);

	    // Build the URL with the record ID and computed text hash.
	    const url = "/push?id=" + encodeURIComponent(anchorHash) +
	                "&h=" + encodeURIComponent(textHashBase64);

	    // Send the POST with the encrypted binary payload.
	    const response = await fetch(url, {
	      method: "POST",
	      headers: {
	        "Content-Type": "application/octet-stream",
	        "Content-Encoding": "identity"
	      },
	      body: encryptedData
	    });

	    if (response.ok) {
	      removeEdited(anchor);  // We have the last version since we overwrote the server's copy.
	      // console.log("Push successful");
	    } else {
	      console.error("Push failed with status", response.status);
	    }
	  } catch (err) {
	    console.error("Push error:", err);
	  } finally {
	    pushButton.disabled = false;
	  }
	});

	// -------------------- PULL --------------------

	async function pullRemote() {
	  // Disable the pull button immediately.
	  pullButton.disabled = true;

	  // anchor is your seed.
	  const seed = anchor;
	  
	  // Use cached computed hashes if available.
	  if (!computedHashes[seed]) {
	    computedHashes[seed] = await computeHashes(seed);
	  }
	  const { anchorHash, h2 } = computedHashes[seed];

	  try {
	    const url = "/pull?id=" + encodeURIComponent(anchorHash);
	    const response = await fetch(url);
	    if (response.ok) {
	      // Get the encrypted binary data from the response.
	      const encryptedData = await response.arrayBuffer();

	      // Import the AES key from h2.
	      const aesKey = await importAesKey(h2);

	      // Decrypt the encrypted data.
	      const decryptedCompressedData = await decryptData(encryptedData, aesKey);

	      // Decompress to retrieve the original text.
	      const newText = await uncompressGzipToText(decryptedCompressedData);
	      const prevText = txtArea.value;

	      if (newText !== prevText) {

	      	// update text but reload location
	      	let savedScroll = txtArea.scrollTop;
	      	let caretPosition = txtArea.selectionStart;
	        txtArea.value = newText;
	        setTimeout(function() {
	       	txtArea.scrollTop = parseInt(savedScroll, 10);
	        if (caretPosition !== null)
	        	txtArea.setSelectionRange(parseInt(caretPosition, 10), parseInt(caretPosition, 10));
	        }, 10);

	        //SAVE COPY TO LOCAL STORAGE / FILE for faster load and updates later: saveContent(); // will do directly from the zip
		    //localStorage.setItem("scroll_" + anchor, txtArea.scrollTop);
		    //localStorage.setItem("caret_" + anchor, txtArea.selectionStart);
		    //opfsStorage.setItem(key, compressed); // Fire-and-forget
	      }

	      // remove saved file etc.
	      removeEdited(anchor);

	      //console.log("Pull successful");
	    } else {
	      console.error("Pull failed with status", response.status);
	    }
	  } catch (err) {
	    console.error("Pull error:", err);
	  } finally {
	    // Re-enable the pull button regardless of success or error.
	    pullButton.disabled = false;	  	
	  }
	}

	pullButton.addEventListener("click", async function() {
	  if (pullButton.disabled)
	  	return;
	  pullRemote();
	});

  // ----------------------------------------------------------------


	function encodeKey(key) {
	  const base64 = btoa(unescape(encodeURIComponent(key)));
	  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
	}	

	// OPFS Storage Controller (fire-and-forget writes)
	class OpfsStorage {
	  // Private method (valid in a class)
	  async #getRoot() {
	    return navigator.storage.getDirectory();
	  }

	  // Non-blocking write
	  setItem(key, arrayBuffer) {
	    (async () => {
	      try {
	        const root = await this.#getRoot();
	        const safeKey = encodeKey(key);
	        const fileHandle = await root.getFileHandle(safeKey, { create: true });
	        const writable = await fileHandle.createWritable();
	        await writable.write(arrayBuffer);
	        await writable.close();
	      } catch (error) {
	        console.error('OPFS write error:', error);
	      }
	    })();
	  }

	  // Blocking read
	  async getItem(key) {
	    try {
	      const root = await this.#getRoot();
	      const safeKey = encodeKey(key);
	      const fileHandle = await root.getFileHandle(safeKey);
	      const file = await fileHandle.getFile();
	      return await file.arrayBuffer();
	    } catch (error) {
	      if (error.name === 'NotFoundError') return null;
	      throw error;
	    }
	  }

	  // removeItem if needed
	  async removeItem(key) {
	    try {
	      const root = await this.#getRoot();
	      const safeKey = encodeKey(key);
	      await root.removeEntry(safeKey);
	    } catch (error) {
	      if (error.name !== 'NotFoundError') throw error;
	    }
	  }
	}

	// Create a singleton instance
	const opfsStorage = new OpfsStorage();

	// Add a deleteFile function to match your saveFile/loadFile pattern
	async function deleteFile(key) {
	  try {
	    await opfsStorage.removeItem(key);
	    console.log(`File ${key} deleted successfully`);
	    return true;
	  } catch (error) {
	    console.error('Failed to delete file:', error);
	    return false;
	  }
	}

	// Usage with your existing compression functions
	async function saveFile(key, text) {
	    const compressed = await compressTextToGzip(text);
	    opfsStorage.setItem(key, compressed); // Fire-and-forget
	    return compressed;
	}

	async function loadFile(key) {
	    const compressed = await opfsStorage.getItem(key);
	    return compressed ? await uncompressGzipToText(compressed) : null;
	}


  /****************************
   * Conversation Anchor Code *
   ****************************/

	async function loadFromStorage(savedCaret) {
	    txtArea.value = await loadFile(anchor);
	    setTimeout(function() {
	    	let caretPosInt = parseInt(savedCaret, 10);
	        txtArea.setSelectionRange(caretPosInt, caretPosInt);
	        //txtArea.selectionEnd = txtArea.selectionStart = parseInt(savedCaret, 10);
	        txtArea.blur();
	        txtArea.focus();
	    }, 1);
	    wasEdited = false;  // no difference with the stored content
	}

	function loadContent() {
		// Global conversation anchor code.
		if ( window.location.hash ) {
			anchor = window.location.hash.substring(1);
			document.title = "post.to/#" + anchor;
			let savedCaret = localStorage.getItem(anchor);
			if ( savedCaret === null ) {
			  	pullRemote();
			} else {
			 	loadFromStorage(savedCaret);
			}
		} else {		
			newDoc();
		}
	}

  function saveContent() {
  	if ( wasEdited ) {
	    localStorage.setItem(anchor, txtArea.selectionStart);
	    saveFile(anchor, txtArea.value);
	}
  }

	function hashChangeHandler() {
	// Save current content, caret, and scroll for the old anchor.
		saveContent();  // check if content was edited before saving
		loadContent();
  	}

	// run it right away
	// loadContent();
	document.addEventListener("DOMContentLoaded", loadContent);
  	window.addEventListener("hashchange", hashChangeHandler);
  	
	// Throttle with trailing invocation: 
	// It calls `fn` immediately if 10s have passed since the last call,
	// and if not, it schedules a trailing call that fires after the remaining time.
	/*
	function throttle(fn, delay) {
	  let timeout = null;
	  let lastCall = 0;
	  let lastArgs;

	  return function(...args) {
	    const now = Date.now();
	    const remaining = delay - (now - lastCall);
	    lastArgs = args;
	    
	    // If enough time has passed, call immediately.
	    if (remaining <= 0) {
	      if (timeout) {
	        clearTimeout(timeout);
	        timeout = null;
	      }
	      lastCall = now;
	      fn.apply(this, args);
	    } 
	    // Otherwise, if no trailing call is scheduled, schedule one.
	    else if (!timeout) {
	      timeout = setTimeout(() => {
	        lastCall = Date.now();
	        timeout = null;
	        fn.apply(this, lastArgs);
	      }, remaining);
	    }
	  }
	}
	*/


  // Create a throttled version that saves at most once every 10 seconds.
  // const throttledSaveContent = throttle(saveContent, 10000);
  // txtArea.addEventListener("input", throttledSaveContent);
  
  function editedHandler() {
     wasEdited = true;
     txtArea.removeEventListener("input", editedHandler);
  }

  function removeEdited(anchor) {
     wasEdited = false;
     if ( localStorage.getItem(anchor) !== null ) {
     	opfsStorage.removeItem(anchor);  // should be a file if there is a localStorage key
     	localStorage.removeItem(anchor);  // no error if undefined
     }
     txtArea.addEventListener("input", editedHandler);
  }

  txtArea.addEventListener("input", editedHandler);
  window.addEventListener("beforeunload", saveContent);

  /*****************************************
   * Update on Anchor (hashchange) Events  *
   *****************************************/

	function newDoc() {
		anchor = generateRandomAnchor(30);
		txtArea.value = "";
		setTimeout(function() {
			txtArea.focus();
		}, 0);
		document.title = "post.to/#" + anchor;   
		history.pushState(null, null, '#' + anchor);
		wasEdited = false;	
	}



  /*********************
   * Line Number Logic *
   *********************/
  /*
  function updateVisibleLineNumbers() {
    const lineHeight = 27; // Fixed line height (as defined in CSS).
    const scrollTop = txtArea.scrollTop;
    const remainder = scrollTop % lineHeight;
    const firstLine = Math.floor(scrollTop / lineHeight);
    const clientHeight = txtArea.clientHeight;
    const numVisibleLines = Math.ceil(clientHeight / lineHeight) + 1;
    const totalHeight = txtArea.scrollHeight;
    const numTotalLines = Math.floor(totalHeight / lineHeight);
    const lastLine = Math.min(firstLine + numVisibleLines, numTotalLines);
	rowNumbers.innerHTML = ''; // Clear existing content

	for (let i = firstLine; i < lastLine; i++) {
	  const numberDiv = document.createElement('div');
	  numberDiv.textContent = i <= 2 ? '\u200B' : (i-2); // Skip "0" if needed
	  rowNumbers.appendChild(numberDiv);
	}
    rowNumbers.style.transform = "translateY(-" + (Math.round(remainder * 1000) / 1000 + 27) + "px)";
  }
  */
  
  //txtArea.addEventListener("scroll", updateVisibleLineNumbers);
  //window.addEventListener("resize", updateVisibleLineNumbers);
  //updateVisibleLineNumbers();


  </script>
</body>
</html>
