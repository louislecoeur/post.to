<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebSocket Test Page</title>
  <style>
    @font-face {
      font-family: "JetBrains Mono";
      src: url("webfonts/JetBrainsMono-Regular.woff2") format("woff2");
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    * {
      box-sizing: border-box;      
      margin: 0;
      padding: 0;
      border: none;
      color-scheme: dark;
      font-family: "JetBrains Mono", "SF Mono", Consolas, monospace;
      font-size: 16.5px;    	
      letter-spacing: 0.5px;
      line-height: 27px;
    }
    
    /* Global styles */
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    /* Big textarea occupies the whole page */
    #txtArea {
      padding: 21px;
      padding-left: 65px;
      width: 100%;
      height: 100%;
      color: rgb(225, 225, 225);
      background-color: rgb(27, 27, 27);
      resize: none;
      overflow-y: scroll;
      white-space: pre;
    }

    #txtArea:focus {
      outline: none;
      border: none;
    }

    #rowNumbers {
      padding-top: 21px;
      width: 61px;		
      position: absolute;
      height: 100%;
      color: #515149;
      background-color: rgb(27, 27, 27);
      left: 0;
      top: 0;
      cursor: pointer;
      text-align: center;
    }

	/* Position the container absolutely in the top right corner */
	#topButtons {
	  position: absolute;
	  top: 20px;
	  right: 30px;
	  display: flex;
	  flex-direction: row;  /* Show buttons side by side */
	  gap: 20px;
	  z-index: 1000; /* Ensure buttons appear above other elements */
	}

	/* Common button styling */
	#topButtons button {
	  width: 40px;
	  height: 40px;
	  border-radius: 50%;
	  border: none;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  cursor: pointer;
	  outline: none;
	}


	/* "Push" button: green circle with an upward arrow */
	#pushButton {
	  background-color: #4CAF50; /* Green */
	}

	/* "Pull" button: blue circle with a downward arrow */
	#pullButton {
	  background-color: #2196F3; /* Blue */
	}

	/* Add a transition to the buttons for smooth effects */
	#topButtons button {
	  transition: transform 0.2s ease, box-shadow 0.2s ease;
	}

	/* On hover, scale up the button and add a subtle shadow */
	#topButtons button:hover {
	  transform: scale(1.1);
	  box-shadow: 0 4px 8px rgba(0, 0, 0, 1);
	}

	/* Common button styling already defined for #pushButton, etc. */

	/* Additional styling for the disabled state of the push button */
	#pushButton.disabled {
	  opacity: 0.6;
	  /*cursor: not-allowed;*/
	  background-color: #388E3C; /* darker green */
	}

	/* You might also add a hover effect for normal state if desired */
	#pushButton:hover:not(.disabled) {
	  transform: scale(1.1);
	  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
	}

	/* Normal push button: green */
	#pushButton {
	  background-color: #4CAF50;
	  color: white;
	}

	/* When active (pressed), make push button darker */
	#pushButton.active {
	  background-color: #388E3C;
	}

	/* Normal pull button: blue */
	#pullButton {
	  background-color: #2196F3;
	  color: white;
	}

	/* When active (pressed), make pull button darker */
	#pullButton.active {
	  background-color: #1976D2;
	}

  </style>
</head>
<body contenteditable="false">
	<textarea id="txtArea" autofocus placeholder=""></textarea>
	<div id="rowNumbers"></div>

	<div id="topButtons">
	  <button id="pushButton" aria-label="Push prompt" title="Push">
	    <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
	      <path fill-rule="evenodd" clip-rule="evenodd" d="M15.1918 8.90615C15.6381 8.45983 16.3618 8.45983 16.8081 8.90615L21.9509 14.049C22.3972 14.4953 22.3972 15.2189 21.9509 15.6652C21.5046 16.1116 20.781 16.1116 20.3347 15.6652L17.1428 12.4734V22.2857C17.1428 22.9169 16.6311 23.4286 15.9999 23.4286C15.3688 23.4286 14.8571 22.9169 14.8571 22.2857V12.4734L11.6652 15.6652C11.2189 16.1116 10.4953 16.1116 10.049 15.6652C9.60265 15.2189 9.60265 14.4953 10.049 14.049L15.1918 8.90615Z" fill="currentColor"></path>
	    </svg>
	  </button>
	  <button id="pullButton" aria-label="Pull prompt" title="Pull">
	    <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: rotate(180deg);">
	      <path fill-rule="evenodd" clip-rule="evenodd" d="M15.1918 8.90615C15.6381 8.45983 16.3618 8.45983 16.8081 8.90615L21.9509 14.049C22.3972 14.4953 22.3972 15.2189 21.9509 15.6652C21.5046 16.1116 20.781 16.1116 20.3347 15.6652L17.1428 12.4734V22.2857C17.1428 22.9169 16.6311 23.4286 15.9999 23.4286C15.3688 23.4286 14.8571 22.9169 14.8571 22.2857V12.4734L11.6652 15.6652C11.2189 16.1116 10.4953 16.1116 10.049 15.6652C9.60265 15.2189 9.60265 14.4953 10.049 14.049L15.1918 8.90615Z" fill="currentColor"></path>
	    </svg>
	  </button>
	</div>

  <script>



	function hash(x) {
	  // For now, return x as is.
	  return x;
	}

	function compress(x) {
	  // Identity for now.
	  return x;
	}

	function decompress(x) {
	  // Identity for now.
	  return x;
	}

	// Push button: post data when clicked.
	document.getElementById("pushButton").addEventListener("click", async function() {
	  const pushButton = this;
	  
	  // Prevent double clicks if already disabled.
	  if (pushButton.disabled) return;
	  
	  // Add active class to show pressed state.
	  pushButton.classList.add("active");
	  pushButton.disabled = true;  // disable button during async operation

	  // Prepare payload.
	  const text = txtArea.value;
	  const compressedText = compress(text);
	  const anchorHash = hash(convAnchor);
	  const payload = { data: compressedText, id: anchorHash };

	  try {
	    const response = await fetch("/push", {
	      method: "POST",
	      headers: { "Content-Type": "application/json" },
	      body: JSON.stringify(payload)
	    });
	    if (response.ok) {
	      console.log("Push successful");
	    } else {
	      console.error("Push failed with status", response.status);
	    }
	  } catch (err) {
	    console.error("Push error:", err);
	  } finally {
	    // Remove active class and re-enable the button.
	    pushButton.classList.remove("active");
	    pushButton.disabled = false;
	  }
	});

	// Pull button: GET data when clicked.
	document.getElementById("pullButton").addEventListener("click", async function() {
	  const pullButton = this;
	  // Add active class for visual feedback.
	  pullButton.classList.add("active");

	  const anchorHash = hash(convAnchor);
	  try {
	    const response = await fetch("/pull?id=" + encodeURIComponent(anchorHash));
	    if (response.ok) {
	      const result = await response.text();
	      txtArea.value = decompress(result);
	      console.log("Pull successful");
	    } else {
	      console.error("Pull failed with status", response.status);
	    }
	  } catch (err) {
	    console.error("Pull error:", err);
	  } finally {
	    // Remove the active class after the pull operation.
	    pullButton.classList.remove("active");
	  }
	});


  /****************************
   * Conversation Anchor Code *
   ****************************/
	// Global conversation anchor code.
	let convAnchor = localStorage.getItem('conversationAnchor');
	if (!convAnchor) {
	  convAnchor = generateRandomAnchor(20);
	  localStorage.setItem('conversationAnchor', convAnchor);
	}
	if (!window.location.hash) {
	  window.location.hash = convAnchor;
	} else if (window.location.hash.substring(1) !== convAnchor) {
	  convAnchor = window.location.hash.substring(1);
	  localStorage.setItem('conversationAnchor', convAnchor);
	}
	let contentKey = "content_" + convAnchor;
	function generateRandomAnchor(length) {
	  const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
	  let result = '';
	  for (let i = 0; i < length; i++) {
	    result += charset.charAt(Math.floor(Math.random() * charset.length));
	  }
	  return result;
	}

  /******************************************
   * Load & Throttled Save Content to Storage *
   ******************************************/
  const txtArea = document.getElementById("txtArea");
  const rowNumbers = document.getElementById("rowNumbers");

  // Load any saved content for this anchor.
  const savedContent = localStorage.getItem(contentKey);
  if (savedContent !== null) {
    txtArea.value = savedContent;
    // Load caret position.
    const caretPosition = localStorage.getItem("caret_" + convAnchor);
    if (caretPosition !== null) {
      setTimeout(function() {
        txtArea.focus();
        txtArea.setSelectionRange(parseInt(caretPosition, 10), parseInt(caretPosition, 10));
      }, 0);
    }
    // Load scroll position.
    const savedScroll = localStorage.getItem("scroll_" + convAnchor);
    if (savedScroll !== null) {
      setTimeout(function() {
        txtArea.scrollTop = parseInt(savedScroll, 10);
        updateVisibleLineNumbers();
      }, 0);
    }
  }
  
  // Throttle helper: ensures a function is called at most once every delay ms.
  function throttle(fn, delay) {
    let lastCall = 0;
    return function(...args) {
      const now = Date.now();
      if (now - lastCall >= delay) {
        lastCall = now;
        fn.apply(this, args);
      }
    };
  }

  function saveContent() {
    localStorage.setItem(contentKey, txtArea.value);
    localStorage.setItem("caret_" + convAnchor, txtArea.selectionStart);
    localStorage.setItem("scroll_" + convAnchor, txtArea.scrollTop);
    //console.log("Saved content, caret and scroll for anchor", convAnchor, "at", new Date().toLocaleTimeString());
  }

  // Create a throttled version that saves at most once every 10 seconds.
  const throttledSaveContent = throttle(saveContent, 10000);
  txtArea.addEventListener("input", throttledSaveContent);
  window.addEventListener("beforeunload", saveContent);

  /*****************************************
   * Update on Anchor (hashchange) Events  *
   *****************************************/
  window.addEventListener("hashchange", function() {
    // Save current content, caret, and scroll for the old anchor.
    saveContent();
    // Update convAnchor from the new URL hash.
    convAnchor = window.location.hash.substring(1);
    localStorage.setItem('conversationAnchor', convAnchor);
    // Update the key used for saving/loading content.
    contentKey = "content_" + convAnchor;
    // Load content for the new anchor, if it exists.
    const newContent = localStorage.getItem(contentKey);
    if (newContent !== null) {
      txtArea.value = newContent;
      const newCaret = localStorage.getItem("caret_" + convAnchor);
      if (newCaret !== null) {
        setTimeout(function() {
          txtArea.focus();
          txtArea.setSelectionRange(parseInt(newCaret, 10), parseInt(newCaret, 10));
        }, 0);
      }
      const newScroll = localStorage.getItem("scroll_" + convAnchor);
      if (newScroll !== null) {
        setTimeout(function() {
          txtArea.scrollTop = parseInt(newScroll, 10);
          updateVisibleLineNumbers();
        }, 0);
      }
    } else {
      // If there's no saved content, clear the textarea and focus it.
      txtArea.value = "";
      setTimeout(function() {
        txtArea.focus();
      }, 0);
    }
  });

  /*********************
   * Line Number Logic *
   *********************/
  function updateVisibleLineNumbers() {
    const lineHeight = 27; // Fixed line height (as defined in CSS).
    const scrollTop = txtArea.scrollTop;
    const remainder = scrollTop % lineHeight;
    const firstLine = Math.floor(scrollTop / lineHeight);
    const clientHeight = txtArea.clientHeight;
    const numVisibleLines = Math.ceil(clientHeight / lineHeight) + 1;
    const totalHeight = txtArea.scrollHeight;
    const numTotalLines = Math.floor(totalHeight / lineHeight);
    const lastLine = Math.min(firstLine + numVisibleLines, numTotalLines);
    let numbers = "";
    for (let i = firstLine; i < lastLine; i++) {
      numbers += (i === 0 ? "" : i) + "\n";
    }
    rowNumbers.innerText = numbers;
    rowNumbers.style.transform = "translateY(-" + (Math.round(remainder * 1000) / 1000 + 27) + "px)";
  }
  
  txtArea.addEventListener("scroll", updateVisibleLineNumbers);
  window.addEventListener("resize", updateVisibleLineNumbers);
  updateVisibleLineNumbers();


  </script>
</body>
</html>
